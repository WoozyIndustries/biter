mod sync;
mod system_clipboard;

use anyhow;
use colored::*;
use copypasta::{ClipboardContext, ClipboardProvider};
use iroh::base::ticket::Ticket;
use iroh::client::LiveEvent;
use iroh::net::key::PublicKey;
use iroh::node::Node;
use iroh::rpc_protocol::ShareMode;
use log::{debug, error, info};
use tokio;
use tokio_stream::StreamExt;
use tokio_util::task::LocalPoolHandle;

use std::collections::HashMap;
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

use system_clipboard::MemClip;

// Glossary
// --------------------------------------------------------------------------------
// * iroh document: see https://iroh.computer/docs/layers/documents.
//
// * memclip: an in-memory `String` for keeping track of clipboard changes between
//            our system and the remote clipboard (iroh document).
//

// Design
// --------------------------------------------------------------------------------
// Uses three threads:
// 1. Main thread manages iroh node, and subscribes to events on the remote doc:
//    * Keeps track of peers we are syncing with.
//    * Updates our memclip (in-memory clipboard for syncing between threads) when
//      peers write to it.
//
// 2. Clipboard thread (`cb_thread`) watches for changes to the system clipboard,
//    updates our memclip, and
//

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // RUST_LOG=biter=debug
    env_logger::init();

    let mut clipboard = ClipboardContext::new().expect(
        "shiiiiiittttt the clipboard didn't work. what the hell goofy ass OS are you running?",
    );
    let memclip_pair = Arc::new((
        Mutex::new(MemClip::new(clipboard.get_contents().unwrap())),
        Condvar::new(),
    )); // In memory var representing the clipboard contents (for syncing).

    // Start the clipboard thread.
    let _cb_thread =
        thread::spawn(move || system_clipboard::watch(clipboard, Arc::clone(&memclip_pair)));

    // Create an iroh runtime with one worker thread, reusing the tokio runtime.
    // Set up Iroh with in-memory blob and document stores, and start the node.
    let lp = LocalPoolHandle::new(1);
    let blob_store = iroh::bytes::store::mem::Store::default();
    let doc_store = iroh::sync::store::memory::Store::default();
    let node = Node::builder(blob_store, doc_store)
        .local_pool(&lp)
        .spawn()
        .await?;
    let client = node.client();
    info!("{}", "started iroh node".green());

    let mut devices: HashMap<PublicKey, bool> = HashMap::new(); // To store pub keys of other iroh nodes
                                                                // syncing our document. Stores them as
                                                                // bools to represent whether or not those
                                                                // devices are actively syncing the doc (are
                                                                // online. TODO: add some sort of way to
                                                                // verify the device keys through the UI
                                                                // before adding them.

    // Setup the iroh document.
    let author = client
        .authors
        .create()
        .await
        .expect("â­• ðŸšŒâ€¼ couldn't create an author. HoOh.");
    let doc = client
        .docs
        .create()
        .await
        .expect("oh ðŸ…±uck. couldn't create a document. HooOh.");
    let doc_ticket = doc
        .share(ShareMode::Write)
        .await
        .expect("could not create doc ticket :( booooooo");

    info!(
        "go check out the document dog: {}",
        doc_ticket.serialize().cyan()
    );

    // Initialize and start the conditional variable thread.
    let _cv_thread = thread::spawn(move || {
        sync::wait_on_memclip(author.clone(), doc.clone(), Arc::clone(&memclip_pair))
    });

    let mut stream = doc.subscribe().await.expect("well I'll ðŸ¦§ðŸ’¨. couldn't subrscibe to the document, I guess something done got all ðŸšŒed ðŸ†™");
    debug!("starting iroh remote content event loop");

    loop {
        while let Some(event) = stream.next().await {
            debug!("event is here {:?}", event);
            match event {
                Ok(e) => {
                    match e {
                        LiveEvent::InsertRemote { from, entry, .. } => {
                            // For now we support 69MB ðŸ¤™ðŸ¥´ðŸ¤™.
                            if entry.key() == "memclip".as_bytes() && entry.content_len() < 72351744
                            {
                                debug!(
                                    "new memclip entry from {} with content hash: {}",
                                    from.fmt_short().cyan(),
                                    entry.content_hash()
                                );
                                debug!(
                                    "||||||| adding 2 second sleep temporarily to test ||||||||"
                                );
                                thread::sleep(Duration::from_secs(2));
                                match entry.content_bytes(&doc).await {
                                    Ok(bytes) => {
                                        let (memclip, _cvar) = &*memclip_pair;
                                        let mut mc = memclip.lock().unwrap();
                                        match String::from_utf8(bytes.to_vec()) {
                                            Ok(s) => {
                                                *mc = MemClip::new(s);
                                                debug!(
                                                    "memclip set to remote content: {}",
                                                    entry.content_hash().to_hex().cyan()
                                                )
                                            }
                                            Err(err) => {
                                                error!(
                                                    "error occurred during document sync (string conversion): {}",
                                                    err.to_string().red()
                                                )
                                            }
                                        }
                                    }
                                    Err(err) => {
                                        error!(
                                            "error occurred during document sync: {}",
                                            err.to_string().red()
                                        )
                                    }
                                }
                            }
                        }

                        // TODO: Do something UI side to allow validating the public keys
                        // of devices, and giving them some kind of user friendly nickname.
                        LiveEvent::NeighborUp(pub_key) => {
                            devices.insert(pub_key, true);
                            info!(
                                "new peer device joined document with public key: {}",
                                pub_key.fmt_short().cyan()
                            );
                        }
                        LiveEvent::NeighborDown(pub_key) => {
                            devices
                                .entry(pub_key)
                                .and_modify(|e| *e = false)
                                .or_insert(false); // Man, I miss Python dictionaries.
                            info!(
                                "peer device left the document: {}",
                                pub_key.fmt_short().cyan()
                            );
                        }

                        _ => {} // Default case, we can ignore other events for now.
                    }
                }
                Err(err) => error!(
                    "something went wrong with a {}: {}",
                    "LiveEvent".magenta(),
                    err.to_string().red()
                ),
            }
        }
    }

    Ok(())
}
